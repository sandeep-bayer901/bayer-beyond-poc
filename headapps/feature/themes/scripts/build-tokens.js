const StyleDictionaryPackage = require("style-dictionary");
const fs = require("fs");

const tokensPath = "src/tokens";
const sites = fs.readdirSync(tokensPath);

const getConfig = (site) => {
  return {
    source: [`${tokensPath}/${site}/transformed.json`],
    platforms: {
      css: {
        transformGroup: "custom/css",
        files: [
          {
            format: "css/variables",
            destination: `${tokensPath}/${site}/tokens.css`,
          },
          {
            format: "google-fonts",
            destination: `${tokensPath}/${site}/fonts.css`,
            filter: {
              attributes: {
                category: "fontFamilies",
              },
            },
          },
        ],
      },
    },
  };
};

const themeTemplate = (site, data, fonts) => {
  const render = `
    // GENERATED BY build-tokens.js
    import React from 'react';
    import Head from 'next/head';

    const ${site} = () => {
        return (
          <Head>
            <style
                dangerouslySetInnerHTML={{
                  __html: "${fonts} ${data}",
                }}
              />
          </Head>
        );
    };
    export default ${site};
  `;
  return render;
};

const themeProvider = (sites) => {
  const siteImport = (site) => {
    return `\n${site}: dynamic(() => import('./sites/${site}'))`
  }

  const render = `
    // GENERATED BY build-tokens.js
    import React, { JSX } from 'react';
    import dynamic from "next/dynamic";

    export type ThemeProviderProps = {
      site?: string;
    };

    const themes : any = {
      ${sites.map((site) => siteImport(site))}
    };

    export const ThemeProvider = ({ site = "Blueprint" }: ThemeProviderProps): JSX.Element => {
      const Theme = themes[site];
      return <Theme />;
    };
  `;

  return render;
};

console.log("Build started...");

sites.map((site) => {
  console.log("\n==============================================");
  console.log(`\nProcessing: [${site}]`);

  StyleDictionaryPackage.registerTransform({
    name: "size/rem",
    type: "value",
    matcher: (token) =>
      token.type === "fontSize" && Number.isFinite(token.value),
    transformer: function (token) {
      return `${token.value * 0.0625}rem`;
    },
  });

  StyleDictionaryPackage.registerTransform({
    name: "weight/numeric",
    type: "value",
    matcher: (token) => token.type === "fontWeight",
    transformer: function (token) {
      let weight;
      switch (token.value) {
        case "ExtraLight":
          weight = 300;
          break;
        case "Regular":
          weight = 400;
          break;
        case "SemiBold":
          weight = 600;
          break;
        case "Bold":
          weight = 700;
        default:
          weight = "normal";
      }
      return weight;
    },
  });

  StyleDictionaryPackage.registerTransform({
    name: "typography/shorthand",
    type: "value",
    transitive: true,
    matcher: (token) => token.type === "typography",
    transformer: (token) => {
      const { value } = token;
      const fontName = value.fontFamily
        .replace(/(\w)(\w*)/g, (g0, g1, g2) => {
          return g1.toUpperCase() + g2.toLowerCase();
        })
        .replace(/-/, " ");

      return `${value.fontWeight} ${value.fontSize * 0.0625}rem/${
        value.lineHeight
      } '${fontName}', sans-serif`;
    },
  });

  StyleDictionaryPackage.registerTransform({
    name: "shadow/shorthand",
    type: "value",
    transitive: true,
    matcher: (token) => token.type === "boxShadow",
    transformer: (token) => {
      let { value } = token;
      if (Array.isArray(value)) {
        value = value[0];
      }
      return `${value.x}px ${value.y}px ${value.blur}px ${value.spread}px ${value.color}`;
    },
  });

  StyleDictionaryPackage.registerTransformGroup({
    name: "custom/css",
    transforms: StyleDictionaryPackage.transformGroup["css"].concat([
      "size/rem",
      "weight/numeric",
      "typography/shorthand",
      "shadow/shorthand",
    ]),
  });

  StyleDictionaryPackage.registerFormat({
    name: "google-fonts",
    formatter: ({ allTokens }) => {
      return allTokens
        .reduce((fonts, prop) => {
          const fontName = prop.value
            .replace(/(\w)(\w*)/g, (g0, g1, g2) => {
              return g1.toUpperCase() + g2.toLowerCase();
            })
            .replace(/-/, "+");

          fonts.push(
            [
              `@import url('https://fonts.googleapis.com/css2?family=${fontName}:wght@300;400;600;700;900&display=swap');`,
            ].join("")
          );

          return fonts;
        }, [])
        .join("\n");
    },
  });

  const StyleDictionary = StyleDictionaryPackage.extend(getConfig(site));

  StyleDictionary.buildAllPlatforms();

  console.log("\nEnd processing");

  const css = fs
    .readFileSync(`${tokensPath}/${site}/tokens.css`, (err, data) => {
      if (err) throw err;
    })
    .toString()
    .replace(/(\r\n|\n|\r)/gm, "");

  const fonts = fs
    .readFileSync(`${tokensPath}/${site}/fonts.css`, (err, data) => {
      if (err) throw err;
    })
    .toString()
    .replace(/(\r\n|\n|\r)/gm, "");

  fs.writeFile(
    `src/components/ThemeProvider/sites/${site}.tsx`,
    themeTemplate(site, css, fonts),
    () => {
      console.log(`\n${site} component theme created at components/sites`);
    }
  );
});

fs.writeFile(
  `src/components/ThemeProvider/ThemeProvider.tsx`,
  themeProvider(sites),
  () => {
    console.log(`\nThemeProvider.tsx was updated.`);
  }
);